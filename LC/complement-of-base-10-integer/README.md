## 1009. Complement of Base 10 Integer

`Bit Manipulation`
      
The complement of an integer is the integer you get when you flip all the `0's` to `1's` and all the `1's` to `0's` in its binary representation.

For example, The integer `5` is "`101`" in binary and its complement is "`010`" which is the integer `2`.
Given an integer n, return its complement.



- Example 1:

  - **Input**: n = 5
  - **Output**: 2
  - **Explanation**: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
___
- Example 2:

  - Input: n = 7
  - Output: 0
  - Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
___
- Example 3:

  - **Input**: n = 10
  - **Output**: 5
  - **Explanation**: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.


Constraints:

0 <= n < 109


# 🧮 Комплемент целого числа с помощью побитовых операций

## 📌 Описание
Данный код вычисляет **битовый комплемент** числа `n`, инвертируя все его биты.

### 🔍 **Как это работает?**
Комплемент числа — это число, полученное путем замены всех `0` на `1` и всех `1` на `0` в двоичном представлении.

Пример:
- `n = 5` → `101` (в двоичной системе) → **Комплемент**: `010` → `2` (в десятичной системе)
- `n = 7` → `111` (в двоичной системе) → **Комплемент**: `000` → `0`

---

## 💡 **Реализация в Java**
```java
public int bitwiseComplement(int n) {
    if (n == 0) return 1;  // Специальный случай
    
    int mask = 1;
    while (mask <= n) {
        mask = mask << 1;
    }
    mask -= 1; // Убираем лишний бит
    
    return n ^ mask;
}
```

---

## 📖 **Пошаговый разбор кода**
### 1️⃣ **Обработка специального случая**
```java
if (n == 0) return 1;  // Специальный случай
```
🔹 Если `n = 0`, его комплемент **всегда** `1`.

---

### 2️⃣ **Создание маски**
```java
int mask = 1;
```
🔹 `mask` инициализируется `1` (`0001` в двоичной системе).

---

### 3️⃣ **Формирование маски `111...`**
```java
while (mask <= n) {
    mask = mask << 1;
}
```
🔹 Сдвигаем `mask` влево (`<<`), пока он не станет больше `n`.

Пример для `n = 5` (`101` в двоичном виде):

| Итерация | `mask` (десятичное) | `mask` (двоичное)       |
|----------|---------------------|-------------------------|
| Начало   | 1                   | `0001`                  |
| 1-я      | 2                   | `0010`                  |
| 2-я      | 4                   | `0100`                  |
| 3-я      | 8                   | `1000` (выход из цикла) |

---

### 4️⃣ **Коррекция маски**
```java
mask -= 1; // Убираем лишний бит
```
🔹 `1000 - 1 = 0111` → теперь `mask` покрывает только значащие биты `n`.

---

### 5️⃣ **Инвертирование битов `n`**
```java
return n ^ mask;
```
🔹 Оператор **XOR (`^`)** инвертирует все биты `n`, используя `mask`.

Пример для `n = 5` (`101` в двоичной системе):
```
  101  (n = 5)
^ 111  (mask = 7)
-------
  010  (результат = 2)
```
✅ Ответ: `2`

---

## 🔥 **Таблица работы кода**
| `n`  | `mask` (генерация) | `mask` (исправлен) | `n ^ mask` (результат) |
|------|--------------------|--------------------|------------------------|
| `5`  | `1000 (8)`         | `0111 (7)`         | `010 (2)`              |
| `7`  | `1000 (8)`         | `0111 (7)`         | `000 (0)`              |
| `10` | `10000 (16)`       | `01111 (15)`       | `101 (5)`              |

---

## 🎯 **Вывод**
✅ **Что делает код?**
1. **Находит наибольшую степень двойки, превышающую `n`**.
2. **Создает маску `111...`, равную по размеру `n`**.
3. **Инвертирует биты `n` с помощью `XOR`**.

🔹 **Время выполнения: `O(log n)`**.
🚀 **Оптимальное и простое решение!**



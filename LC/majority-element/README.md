# 169. Majority Element

`Array` `Hash Table` `Divide and Conquer` `Sorting` `Counting`

Given an array nums of size `n`, return the majority element.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.



### Example 1:

- **Input**: nums = `[3,2,3]`
- **Output**: `3`
___
### Example 2:

- **Input**: nums = `[2,2,1,1,1,2,2]`
- **Output**: `2`
____

### Constraints:

`n == nums.length`

`1 <= n <= 5 * 104`

`-109 <= nums[i] <= 109`


Follow-up: Could you solve the problem in linear time and in O(1) space?

### **Разбор решения "Поиск мажоритарного элемента"**

#### **Задача в двух словах**
Найти **элемент, встречающийся более чем ⌊n / 2⌋ раз** в массиве `nums`.

---

## **Как работает алгоритм?**
Этот алгоритм основан на **алгоритме Бойера-Мура для поиска мажоритарного элемента (Boyer-Moore Voting Algorithm)**.

---

### **Разбор кода**
```java
public int majorityElement(int[] nums) {
    int candidate = nums[0]; // Текущий кандидат в мажоритарные элементы
    int count = 1; // Счетчик голосов

    // Первый проход: нахождение кандидата
    for (int i = 1; i < nums.length; i++) {
        if (count == 0) {
            candidate = nums[i]; // Если счетчик обнулился, назначаем нового кандидата
            count = 1;
        } else if (nums[i] == candidate) {
            count++; // Если элемент совпадает с кандидатом, увеличиваем счетчик
        } else {
            count--; // Если элемент другой, уменьшаем счетчик
        }
    }

    // Возвращаем найденного кандидата (по условию задачи он всегда будет мажоритарным)
    return candidate;
}
```

---

## **Как работает алгоритм Бойера-Мура?**
1. **Первый проход:**
    - **Выбираем кандидата** и следим за его "поддержкой" (`count`).
    - Если `count == 0`, назначаем нового кандидата.
    - Если встречаем тот же элемент, **увеличиваем** `count`, иначе **уменьшаем**.
    - В конце первого прохода **гарантированно** остается мажоритарный элемент (если он существует).

---

## **Пример работы**
### **Входные данные**
```java
nums = [3, 3, 4, 2, 3, 3, 3]
```

| Шаг | i | nums[i] | candidate | count               |  
|-----|---|---------|-----------|---------------------|  
| 1   | 0 | 3       | 3         | 1                   |  
| 2   | 1 | 3       | 3         | 2                   |  
| 3   | 2 | 4       | 3         | 1                   |  
| 4   | 3 | 2       | 3         | 0 (смена кандидата) |  
| 5   | 4 | 3       | 3         | 1                   |  
| 6   | 5 | 3       | 3         | 2                   |  
| 7   | 6 | 3       | 3         | 3                   |  

**Ответ:** `3` (мажоритарный элемент).

---

## **Почему алгоритм работает?**
- Если существует **мажоритарный элемент (> n/2 раз)**, он **не может быть полностью отменен** в процессе голосования.
- Элементы, которых **меньше половины**, всегда будут "перекрыты" мажоритарным.

---

## **Сложность алгоритма**
- **Временная сложность**: `O(n)`, так как **проходим массив всего один раз**.
- **Доп. память**: `O(1)`, так как **используем только две переменные (`candidate`, `count`)**.

---

## **Вывод**
Алгоритм Бойера-Мура — это **эффективное O(n) решение без доп. памяти**, которое гарантированно находит мажоритарный элемент в массиве, если он существует.


# 1758. Minimum Changes To Make Alternating Binary String

`String`

You are given a string s consisting only of the characters `0` and `1`. In one operation, you can change any `0` to `1` or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string `0100` is not.

Return the minimum number of operations needed to make s alternating.

### Example 1:

- **Input**: s = `0100`
- **Output**: `1`
- **Explanation**: If you change the last character to `1`, s will be `0101`, which is alternating.
___
### Example 2:

- **Input**: s = "`10`"
- **Output**: `0`
- **Explanation**: s is already alternating.
___
### Example 3:

- **Input**: s = "`1111`"
- **Output**: `2`
- **Explanation**: You need two operations to reach "`0101`" or "`1010`"
___

### **Разбор решения задачи "Минимальное количество операций для преобразования строки"**

#### **Задача в двух словах**
Нужно найти **минимальное количество операций**, чтобы преобразовать строку `s`, состоящую из `'0'` и `'1'`, в **чередующуюся строку** (`010101...` или `101010...`).

---

### **Разбор кода**
```java
public int minOperations(String s) {
    int first = 0;  // Количество изменений, если начинаем с '0' (шаблон "010101...")
    int second = 0; // Количество изменений, если начинаем с '1' (шаблон "101010...")

    for (int i = 0; i < s.length(); i++) {
        if(i % 2 == 0) {  // Четные индексы
            if(s.charAt(i) == '1') first++;  // В шаблоне "010101..." должно быть '0'
            else second++;                   // В шаблоне "101010..." должно быть '1'
        } else {  // Нечетные индексы
            if(s.charAt(i) == '1') second++; // В шаблоне "101010..." должно быть '0'
            else first++;                    // В шаблоне "010101..." должно быть '1'
        }
    }
    
    return Math.min(first, second); // Минимальное количество замен из двух вариантов
}
```

---

### **Как работает алгоритм?**
Идем по строке `s` и считаем, сколько ошибок будет в двух возможных вариантах:
1. **Вариант 1**: Начинаем с `'0'` → `"010101..."`
    - Если на **четных индексах** стоит `'1'`, то его нужно заменить → `first++`
    - Если на **нечетных индексах** стоит `'0'`, то его нужно заменить → `first++`

2. **Вариант 2**: Начинаем с `'1'` → `"101010..."`
    - Если на **четных индексах** стоит `'0'`, то его нужно заменить → `second++`
    - Если на **нечетных индексах** стоит `'1'`, то его нужно заменить → `second++`

В конце берем `Math.min(first, second)`, так как **нас интересует минимальное количество замен**.

---

### **Пример работы**
```java
s = "1101"
```
Итерации:

| i | s[i] | Ожид. "0101" | first++? | Ожид. "1010" | second++? |
|---|------|--------------|----------|--------------|-----------|
| 0 | '1'  | '0'          | ✅        | '1'          | ❌         |
| 1 | '1'  | '1'          | ❌        | '0'          | ✅         |
| 2 | '0'  | '0'          | ❌        | '1'          | ✅         |
| 3 | '1'  | '1'          | ❌        | '0'          | ✅         |

- `first = 1` (ошибка на `s[0]`)
- `second = 3` (ошибки на `s[1]`, `s[2]`, `s[3]`)

**Ответ:** `Math.min(1, 3) = 1`

---

### **Сложность алгоритма**
- **Временная сложность**: `O(n)`, так как мы проходим строку **одним циклом**.
- **Доп. память**: `O(1)`, так как используем **только две переменные**.

---

### **Вывод**
Этот алгоритм **эффективно** решает задачу, проходя строку **один раз** и сравнивая два возможных варианта шаблона.

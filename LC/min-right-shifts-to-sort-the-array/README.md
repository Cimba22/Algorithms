# 2855. Minimum Right Shifts to Sort the Array

`Array`

You are given a **0-indexed** array ```nums``` of length `n` containing 
**distinct** positive integers. Return the **minimum** number of **right 
shifts** required to `sort` nums and `-1` if this is not possible.

A **right shift** is defined as shifting
the element at index `i` to index `(i + 1) % n`, for all indices.

**Example 1:**

```Input: nums = [3,4,5,1,2]
Output: 2
Explanation:
After the first right shift, nums = [2,3,4,5,1].
After the second right shift, nums = [1,2,3,4,5].
Now nums is sorted; therefore the answer is 2.
```

**Example 2:**

```Input: nums = [1,3,5]
Output: 0
Explanation: nums is already sorted therefore, the answer is 0.
```

**Example 3:**

```Input: nums = [2,1,4]
Output: -1
Explanation: It's impossible to sort the array using right shifts.
```




### **Разбор решения "Минимальные циклические сдвиги вправо"**

#### **Задача в двух словах**
Нужно определить **минимальное количество циклических сдвигов вправо**, чтобы массив стал **отсортированным по возрастанию**. Если это невозможно — вернуть `-1`.

---

### **Разбор кода**
```java
public int minimumRightShifts(List<Integer> nums) {
    int len = nums.size();

    // Если массив из одного элемента, он уже отсортирован
    if (len == 1) {
        return 0;
    }

    int breakPoints = 0;  // Количество разрывов упорядоченности
    int index = 0;        // Индекс разрыва

    // Проходим по массиву, ищем, где нарушается порядок
    for (int i = 1; i < len; i++) {
        if (nums.get(i - 1) > nums.get(i)) {
            breakPoints++;
            index = i;  // Запоминаем индекс разрыва
        }
    }

    // Если ровно один разрыв и последний элемент меньше первого
    if (breakPoints == 1 && nums.get(len - 1) <= nums.getFirst()) {
        return len - index;  // Количество необходимых сдвигов вправо
    } 
    // Если массив уже отсортирован, сдвигов не нужно
    else if (breakPoints == 0) {
        return 0;
    } 
    // Если разрывов больше одного, отсортировать циклическим сдвигом невозможно
    else {
        return -1;
    }
}
```

---

### **Как работает алгоритм?**
1. **Определяем количество разрывов (breakPoints)**
    - Разрыв (`nums[i-1] > nums[i]`) означает, что последовательность нарушена.
    - Если таких разрывов **больше одного**, то отсортировать циклическим сдвигом **нельзя**.

2. **Определяем, возможно ли исправить массив одним сдвигом**
    - Если **разрыв ровно один**, то проверяем, что **последний элемент массива не больше первого** (`nums[len - 1] <= nums[0]`).
    - Если условие выполнено, то **возвращаем количество сдвигов** (`len - index`).

3. **Обрабатываем частные случаи**
    - Если **разрывов нет**, массив уже отсортирован (`return 0`).
    - Если **разрывов больше одного**, вернуть `-1` (сдвиг не поможет).

---

### **Пример работы**
#### **Пример 1**
```java
nums = [3, 4, 5, 1, 2]
```
- Разрыв **один**: `5 > 1` (на позиции `3`).
- Последний элемент (`2`) **меньше или равен первому** (`3`).
- Сдвигов требуется: `5 - 3 = 2`.

**Ответ:** `2`.

#### **Пример 2**
```java
nums = [2, 3, 4, 5, 1]
```
- Разрыв **один**: `5 > 1` (на позиции `4`).
- Последний элемент (`1`) **меньше первого** (`2`).
- Сдвигов требуется: `5 - 4 = 1`.

**Ответ:** `1`.

#### **Пример 3**
```java
nums = [1, 2, 3, 4, 5]
```
- **Нет разрывов**, массив уже отсортирован.

**Ответ:** `0`.

#### **Пример 4**
```java
nums = [3, 1, 4, 2, 5]
```
- Два разрыва: `3 > 1` и `4 > 2`.
- Нельзя отсортировать циклическим сдвигом.

**Ответ:** `-1`.

---

### **Сложность алгоритма**
- **Временная сложность**: `O(n)`, так как проходим массив **два раза**.
- **Доп. память**: `O(1)`, так как используем только несколько переменных.

---

### **Вывод**
Алгоритм проверяет, можно ли отсортировать массив **циклическим сдвигом вправо**. Если можно — возвращает **количество сдвигов**, если нет — `-1`.




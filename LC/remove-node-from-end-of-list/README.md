# 19. Remove Nth Node From End of List
`Linked List` `Two Pointers`

Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.

### Example 1:
- **Input**: head = `[1,2,3,4,5]`, n = `2`
- **Output**: `[1,2,3,5]`
_____

### Example 2:

- **Input**: head = `[1]`, n = `1`
- **Output**: `[]`

____

### Example 3:

- **Input**: head = `[1,2]`, n = `1`
- **Output**: `[1]`


### Constraints:

The number of nodes in the list is `sz`.

`1 <= sz <= 30`

`0 <= Node.val <= 100`

`1 <= n <= sz`

## Solution:

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head, slow = head;
    for (int i = 0; i < n; i++) fast = fast.next;
    if (fast == null) return head.next;
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return head;
}
```

Это решение задачи на удаление n-го узла с конца в односвязанном списке.

Вот пошаговое объяснение:

1. **Определение ListNode**:
    - Это класс, который представляет узел в односвязанном списке. Каждый узел содержит значение `val` и указатель на следующий узел `next`.

2. **Основной метод: `removeNthFromEnd`**:
    - Метод принимает два аргумента: `head` (голова списка) и `n` (позиция узла с конца, который нужно удалить).

3. **Два указателя — `fast` и `slow`**:
    - Инициализируются два указателя: `fast` и `slow`, которые оба указывают на начало списка (на `head`).
    - Указатель `fast` используется для того, чтобы пройти на n позиций вперёд, а затем оба указателя двигаются вместе, чтобы найти нужный узел для удаления.

4. **Перемещение указателя `fast` на n шагов вперёд**:
    - В цикле `for` указатель `fast` перемещается на `n` шагов вперёд в списке. Теперь разница между указателями `fast` и `slow` составляет `n` узлов.

5. **Проверка на случай, если нужно удалить первый узел**:
    - Если после перемещения указателя `fast` на `n` шагов `fast` равен `null`, это означает, что удаляемый узел — это первый узел списка (голова). В таком случае возвращается `head.next`, что effectively удаляет первый узел.

6. **Передвижение указателей `fast` и `slow` до конца списка**:
    - Теперь оба указателя двигаются одновременно по одному узлу за раз, пока `fast.next` не станет равным `null` (то есть, пока `fast` не достигнет последнего узла).
    - В этот момент указатель `slow` будет указывать на узел, перед тем, который нужно удалить (потому что `fast` на один шаг впереди).

7. **Удаление узла**:
    - Узел, который нужно удалить, находится сразу после `slow`. Чтобы удалить его, нужно изменить ссылку `slow.next`, чтобы она указывала на `slow.next.next`, тем самым пропуская удаляемый узел.

8. **Возвращение головы списка**:
    - В конце метод возвращает изменённую голову списка (или ту же самую, если удаление произошло не с первого узла).

Таким образом, алгоритм эффективно удаляет n-й узел с конца списка, двигаясь лишь один раз по списку с использованием двух указателей. Это решение работает за время O(L), где L — длина списка.